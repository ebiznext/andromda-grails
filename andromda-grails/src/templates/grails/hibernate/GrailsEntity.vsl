##
##  author: stephane.manciot@ebiznext.com, mourad.dachraoui@ebiznext.com
##  
#parse("templates/grails/hibernate/GrailsEntity.vm")
#set($indent ="    ")
#set($generatedFile = "${entity.packagePath}/${entity.entityName}.groovy")
// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: GrailsEntity.vsl in andromda-grails-cartridge.
//
#if ($stringUtils.isNotBlank($entity.packageName))
package $entity.packageName;
#end
/**
$entity.getDocumentation(" * ")
 */
class $entity.entityName
#if($entity.generalization)
${indent}extends $entity.generalization.fullyQualifiedEntityName
#end
${indent}implements java.io.Serializable
{
#set($validationFullyQualifiedName = "")
#if ($stringUtils.isNotBlank($entity.packageName))
#set($validationFullyQualifiedName = "${entity.packageName}.${entity.entityName}Validation")
#else
#set($validationFullyQualifiedName = "${entity.entityName}Validation")
#end
#set($classifierName = "$grailsUtils.getClassifierName($entity)")
${indent}def ${classifierName}Validation
${indent}def ${classifierName}Render

#renderPropertiesAndAssociations($entity "")

${indent}static transients = [ '${classifierName}Validation', '${classifierName}Render' ]
##
##Render mapping Block
##
#renderMappingBlock($entity "")

##
## Constraints block.
## Provide Grails with a declarative DSL for defining validation rules, 
## schema generation and CRUD generation meta data
${indent}static constraints = {
#foreach ($attribute in $entity.attributes)
## Declaring constraints to keep attribut order
#if ($attribute.name != 'id')
${indent}${indent}$attribute.name (#if(!$attribute.required)nullable:true#else blank:false, nullable:false#end, unique:$attribute.unique#if($grailsUtils.hasCustomValidator($attribute)), validator:${validationFullyQualifiedName}.$grailsUtils.getCustomValidatorName($entity, $attribute)#end#if($grailsUtils.isCreditCard($attribute)), creditCard:true#end#if($grailsUtils.isEmail($attribute)), email:true#end#if($grailsUtils.isUrl($attribute)), url:true#end#if($grailsUtils.isRegularExpression($attribute) && $grailsUtils.getMatchesConstraint($attribute)!=''), matches:"$grailsUtils.getMatchesConstraint($attribute)"#elseif($grailsUtils.isRange($attribute) && $grailsUtils.getRangeConstraint($attribute)!=''), range:$grailsUtils.getRangeConstraint($attribute)#end)
#end
#end
#foreach ($sourceEnd in $entity.associationEnds)
#set ($otherEnd = $sourceEnd.otherEnd)
#if ($otherEnd.navigable && !$otherEnd.transient)
#if ($sourceEnd.one2One || $sourceEnd.many2One)
#if (!$otherEnd.aggregation && !$otherEnd.composition)
${indent}${indent}$otherEnd.name (#if(!$otherEnd.required)nullable:true#else blank:false, nullable:false#end#if($grailsUtils.hasCustomValidator($otherEnd)), validator:${validationFullyQualifiedName}.$grailsUtils.getCustomValidatorName($entity, $otherEnd)#end)
#end
#end
#end
#end
${indent}}

##
## only generate the finder methods defined on this entity; i.e. do not
## include those defined on any of the super-entities.
##
#set ($queryOperations = $entity.queryOperations)
#set ($pagination = "false")
##
#foreach ($finder in $queryOperations)
#set ($returnType = $finder.returnType.fullyQualifiedName)
#set ($namedParameters = $stringUtils.isNotBlank($finder.findTaggedValue('@andromda.hibernate.query')))
#if(!$finder.criteriaFinder)
    static $returnType ${finder.name}(${finder.getTypedArgumentList('final')})
#if ($finder.exceptionsPresent)
        throws $finder.exceptionList
#end
#if(!$finder.abstract && !$finder.static)
    {
        return ${entity.entityName}.${finder.name}("$finder.getQuery()"#if(!$finder.arguments.empty), ${finder.argumentNames}#end#if($finder.returnType.collectionType), 0, 0#end);
    }

#if($finder.returnType.collectionType)
#set ($pagination = "true")
    static $returnType ${finder.name}(${finder.getTypedArgumentList('final')}#if(!$finder.arguments.empty),#end int pageNumber, int pageSize)
#if ($finder.exceptionsPresent)
        throws $finder.exceptionList
#end
    {
        return ${entity.entityName}.${finder.name}("$finder.getQuery()"#if(!$finder.arguments.empty), ${finder.argumentNames}#end#if($finder.returnType.collectionType), pageNumber, pageSize#end);
    }

#end
    static $returnType ${finder.name}(final java.lang.String queryString#if(!$finder.arguments.empty), ${finder.getTypedArgumentList('final')}#end#if($finder.returnType.collectionType), int pageNumber, int pageSize#end)
#if ($finder.exceptionsPresent)
        throws $finder.exceptionList
#end
    {
#if($finder.returnType.collectionType)
        def paginateParams = null
        if (pageNumber > 0 && pageSize > 0) {
            paginateParams = [offset : calculateFirstResult(pageNumber, pageSize), max : pageSize]
        }
        return paginateParams ? ${entity.entityName}.executeQuery(queryString, [#foreach($argument in $finder.arguments)#if($velocityCount > 1),#end$argument.name:$argument.name#end], paginateParams) : ${entity.entityName}.executeQuery(queryString, [#foreach($argument in $finder.arguments)#if($velocityCount > 1),#end$argument.name:$argument.name#end])
#else
        def ret = ${entity.entityName}.executeQuery(queryString, [#foreach($argument in $finder.arguments)#if($velocityCount > 1),#end$argument.name:$argument.name#end]).iterator()
        return ret.hasNext()?ret.next():null
#end
    }
#else
##FIXME
##    {
##        return ${delegatorFullyQualifiedName}.${finder.name}(#if(!$finder.arguments.empty)${finder.argumentNames}#end);
##    }

#end
#end
#end
#if($pagination == "true")

    static int calculateFirstResult(int pageNumber, int pageSize) {
        int firstResult = 0
        if (pageNumber > 0) {
            firstResult = (pageNumber - 1) * pageSize
        }
        return firstResult
    }
    
#end

${indent}String toString(){return ${classifierName}Render.asString(this)}

${indent}def beforeInsert = {
${indent}${indent}${classifierName}Validation.beforeInsert(this)
${indent}}

${indent}def beforeUpdate = {
${indent}${indent}${classifierName}Validation.beforeUpdate(this)
${indent}}

${indent}def beforeDelete = {
${indent}${indent}${classifierName}Validation.beforeDelete(this)
${indent}}

${indent}def beforeValidate = {
${indent}${indent}${classifierName}Validation.beforeValidate(this)
${indent}}

${indent}def afterInsert = {
${indent}${indent}${classifierName}Validation.afterInsert(this)
${indent}}

${indent}def afterUpdate = {
${indent}${indent}${classifierName}Validation.afterUpdate(this)
${indent}}

${indent}def afterDelete = {
${indent}${indent}${classifierName}Validation.afterDelete(this)
${indent}}

${indent}def onLoad = {
${indent}${indent}${classifierName}Validation.onLoad(this)
${indent}}

${indent}java.util.Map asMapForJSON() {return ${classifierName}Render.asMap(this)}

${indent}// GrailsEntity.vsl merge-point
}