##
##  author: mourad.dachraoui@ebiznext.com
##      
#parse("templates/grails/hibernate/GrailsEntity.vm")
#set($indent ="    ")
#set($generatedFile = "${embeddedValue.packagePath}/${embeddedValue.name}.groovy")
// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: GrailsEntity.vsl in andromda-grails-cartridge.
//
#if ($stringUtils.isNotBlank($embeddedValue.packageName))
package $embeddedValue.packageName;
#end
#if ($mapSubclassesInSeparateFile && $embeddedValue.generalization)
    // TODO NOt yet supported : muliple subclasses stored in the same database table
#else
/**
$embeddedValue.getDocumentation(" * ")
 */
class $embeddedValue.name implements java.io.Serializable
{
#if (!$embeddedValue.specializations.empty && $embeddedValue.hibernateInheritanceClass)
// This is the GORM discrimator column
##discriminator column="$embeddedValue.hibernateDiscriminatorColumn" type="$embeddedValue.hibernateDiscriminatorType"
#end
#if ($stringUtils.isNotBlank($embeddedValue.hibernateVersionProperty))
// GORM version management stratgey
##version name="$embeddedValue.hibernateVersionProperty" type="int" column="$embeddedValue.hibernateVersionProperty"
#end
// If super inheritance is 'interface', render super properties etc
#foreach ($generalization in $embeddedValue.allGeneralizations)
#if($generalization.mappingRequiresSuperProperties)
#renderPropertiesAndAssociations($generalization "")
#end
#end
// render the properties and associations (if any)
#renderPropertiesAndAssociations($embeddedValue "")
#if ($embeddedValue.requiresSpecializationMapping)
// render the subclass elements if class or subclass strategy
#foreach ($specialization in $embeddedValue.specializations)
// renderSubClass3($specialization "        ")
#end## foreach
#end## ($embeddedValue.requiresMappingSpecialization)
// END Entity 
#end

##
##Render mapping Block
##

#renderMappingBlock($embeddedValue "")
## Constraints block.
## Provide Grails with a declarative DSL for defining validation rules, 
## schema generation and CRUD generation meta data

${indent}static constraints = {
#foreach ($attribute in $embeddedValue.attributes)
## Declaring constraints to keep attribut order
#if ($attribute.name != 'id')
${indent}${indent}$attribute.name (#if(!$attribute.required)nullable:true#else blank:false, nullable:false#end, unique:$attribute.unique#if($grailsUtils.hasCustomValidator($attribute)), validator:#if($stringUtils.isNotEmpty($customTypesPackage)) ${customTypesPackage}.Validators.#else Validators.#end$grailsUtils.getCustomValidatorName($embeddedValue, $attribute)#end#if($grailsUtils.isCreditCard($attribute)), creditCard:true#end#if($grailsUtils.isEmail($attribute)), email:true#end#if($grailsUtils.isUrl($attribute)), url:true#end#if($grailsUtils.isRegularExpression($attribute) && $grailsUtils.getMatchesConstraint($attribute)!=''), matches:"$grailsUtils.getMatchesConstraint($attribute)"#elseif($grailsUtils.isRange($attribute) && $grailsUtils.getRangeConstraint($attribute)!=''), range:$grailsUtils.getRangeConstraint($attribute)#end)
#end
#end
#foreach ($sourceEnd in $embeddedValue.associationEnds)
#set ($otherEnd = $sourceEnd.otherEnd)
#if ($otherEnd.navigable && !$otherEnd.transient)
#if ($sourceEnd.one2One)
#if (!$otherEnd.aggregation && !$otherEnd.composition)
${indent}${indent}$otherEnd.name (#if(!$otherEnd.required)nullable:true#else blank:false, nullable:false#end#if($grailsUtils.hasCustomValidator($otherEnd)), validator:#if($stringUtils.isNotEmpty($customTypesPackage)) ${customTypesPackage}.Validators.#else Validators.#end$grailsUtils.getCustomValidatorName($embeddedValue, $otherEnd)#end)
#end
#end
#end
#end
${indent}}

##
## only generate the finder methods defined on this entity; i.e. do not
## include those defined on any of the super-entities.
##
#set ($queryOperations = $embeddedValue.queryOperations)
##
#foreach ($finder in $queryOperations)
#set ($returnType = $finder.returnType.fullyQualifiedName)
#set ($namedParameters = $stringUtils.isNotBlank($finder.findTaggedValue('@andromda.hibernate.query')))

#if(!$finder.criteriaFinder)
    static $returnType ${finder.name}(${finder.getTypedArgumentList('final')})
#if ($finder.exceptionsPresent)
        throws $finder.exceptionList
#end
    {
        return ${embeddedValue.name}.${finder.name}("$finder.getQuery()"#if(!$finder.arguments.empty), ${finder.argumentNames}#end);
    }

    static $returnType ${finder.name}(final java.lang.String queryString#if(!$finder.arguments.empty), ${finder.getTypedArgumentList('final')}#end)
#if ($finder.exceptionsPresent)
        throws $finder.exceptionList
#end
    {
        return ${embeddedValue.name}.find#if($finder.returnType.collectionType)All#end(queryString, [#foreach($argument in $finder.arguments)#if($velocityCount > 1),#end#if($namedParameters)$argument.name:#end$argument.name#end])
    }
#end
#end
${indent}// GrailsEntity.vsl merge-point
}